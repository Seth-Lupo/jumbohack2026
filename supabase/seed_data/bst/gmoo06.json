{
  "style": "C++ Binary Search Tree implementation with pointers and recursion",
  "description": "Grace Moore: 45 flushes, 45.5 min total time",
  "flushes": [
    {
      "file_path": "node.h",
      "diffs": "-\n+#ifndef NODE_H\n+#define NODE_H\n+\n+struct Node  {\n+    int curr_node1;\n+    Node* currPtr;\n+    Node* tmp2;\n+\n+    Node(int val) : curr_node1(val), currPtr(nullptr), tmp2(nullptr) {}\n+};\n+\n+#endif\n+",
      "content": "#ifndef NODE_H\n#define NODE_H\n\nstruct Node  {\n    int curr_node1;\n    Node* currPtr;\n    Node* tmp2;\n\n    Node(int val) : curr_node1(val), currPtr(nullptr), tmp2(nullptr) {}\n};\n\n#endif\n",
      "active_symbol": "Node",
      "trigger": "init",
      "window_duration": 5.274436320563799
    },
    {
      "file_path": "bst.h",
      "diffs": "-\n+#ifndef BST_H\n+#define BST_H\n+\n+#include \"tmp1.h\"\n+\n+class BST  {\n+public:\n+    BST();\n+    ~BST();\n+\n+    void insert(int curr_node1);\n+    bool search(int curr_node1);\n+    void remove(int curr_node1);\n+\n+    void inorder();\n+    void preorder();\n+    void postorder();\n+\n+    int height();\n+    int nodeCount();\n+    bool isValid();\n+\n+private:\n+    Node* root;\n+\n+    Node* insertHelper(Node* tmp1, int curr_node1);\n+    bool searchHelper(Node* tmp1, int curr_node1);\n+    Node* removeHelper(Node* tmp1, int curr_node1);\n+    Node* findMin(Node* tmp1);\n+\n+    void inorderHelper(Node* tmp1);\n+    void preorderHelper(Node* tmp1);\n+    void postorderHelper(Node* tmp1);\n+\n+    int heightHelper(Node* tmp1);\n+    int nodeCountHelper(Node* tmp1);\n+    bool isValidHelper(Node* tmp1, int minVal, int maxVal);\n+\n+    void deleteTree(Node* tmp1);\n+};\n+\n+#endif\n+",
      "content": "#ifndef BST_H\n#define BST_H\n\n#include \"tmp1.h\"\n\nclass BST  {\npublic:\n    BST();\n    ~BST();\n\n    void insert(int curr_node1);\n    bool search(int curr_node1);\n    void remove(int curr_node1);\n\n    void inorder();\n    void preorder();\n    void postorder();\n\n    int height();\n    int nodeCount();\n    bool isValid();\n\nprivate:\n    Node* root;\n\n    Node* insertHelper(Node* tmp1, int curr_node1);\n    bool searchHelper(Node* tmp1, int curr_node1);\n    Node* removeHelper(Node* tmp1, int curr_node1);\n    Node* findMin(Node* tmp1);\n\n    void inorderHelper(Node* tmp1);\n    void preorderHelper(Node* tmp1);\n    void postorderHelper(Node* tmp1);\n\n    int heightHelper(Node* tmp1);\n    int nodeCountHelper(Node* tmp1);\n    bool isValidHelper(Node* tmp1, int minVal, int maxVal);\n\n    void deleteTree(Node* tmp1);\n};\n\n#endif\n",
      "active_symbol": "BST",
      "trigger": "init",
      "window_duration": 3.6096883732238036
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+if (node == nullptr) {\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\n",
      "active_symbol": "insert",
      "trigger": "timeout",
      "window_duration": 146.34047405018433
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+if (node == nullptr) {\n+        return new Node(value);\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\n",
      "active_symbol": "insert",
      "trigger": "timeout",
      "window_duration": 138.53716137634444
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+if (node == nullptr) {\n+        return new Node(value);\n+    }\n+    \n+    if (value < node->value) {\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\n",
      "active_symbol": "insert",
      "trigger": "timeout",
      "window_duration": 142.92384880464462
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+if (node == nullptr) {\n+        return new Node(value);\n+    }\n+    \n+    if (value < node->value) {\n+        node->left = insertHelper(node->left, value);\n+    } else if (value > node->value) {\n+        node->right = insertHelper(node->right, value);\n+    }\n+    \n+    return node;\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n",
      "active_symbol": "insert",
      "trigger": "timeout",
      "window_duration": 138.5729656037068
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+if (node == nullptr) {\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\n",
      "active_symbol": "search",
      "trigger": "timeout",
      "window_duration": 162.63382594600364
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+if (node == nullptr) {\n+        return new Node(value);\n+    }\n+    \n+    if (value < node->value) {\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\n",
      "active_symbol": "search",
      "trigger": "timeout",
      "window_duration": 163.81584320219812
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+if (node == nullptr) {\n+        return new Node(value);\n+    }\n+    \n+    if (value < node->value) {\n+        node->left = insertHelper(node->left, value);\n+    } else if (value > node->value) {\n+        node->right = insertHelper(node->right, value);\n+    }\n+    \n+    return node;\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n",
      "active_symbol": "search",
      "trigger": "timeout",
      "window_duration": 161.14164670267644
    },
    {
      "file_path": "bst.cpp",
      "diffs": "+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\n",
      "active_symbol": "traversals",
      "trigger": "timeout",
      "window_duration": 70.77622256525105
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+void BST::inorder() {\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\n",
      "active_symbol": "traversals",
      "trigger": "timeout",
      "window_duration": 66.48830805695496
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+void BST::inorder() {\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\n",
      "active_symbol": "traversals",
      "trigger": "timeout",
      "window_duration": 65.2551235068116
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+void BST::inorder() {\n+    inorderHelper(root);\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\n",
      "active_symbol": "traversals",
      "trigger": "timeout",
      "window_duration": 68.34554034789649
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+void BST::inorder() {\n+    inorderHelper(root);\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\n",
      "active_symbol": "traversals",
      "trigger": "timeout",
      "window_duration": 68.2597313524998
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+void BST::inorderHelper(Node* node) {\n+    if (node == nullptr) return;\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\n",
      "active_symbol": "traversals",
      "trigger": "timeout",
      "window_duration": 70.94137579583274
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+void BST::inorderHelper(Node* node) {\n+    if (node == nullptr) return;\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\n",
      "active_symbol": "traversals",
      "trigger": "timeout",
      "window_duration": 67.85127545100899
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+inorderHelper(node->left);\n+    std::cout << node->value << \" \";\n+    inorderHelper(node->right);\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n",
      "active_symbol": "traversals",
      "trigger": "timeout",
      "window_duration": 66.8739750676823
    },
    {
      "file_path": "bst.cpp",
      "diffs": "+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n\n// ... more methods ...\n",
      "active_symbol": "remove",
      "trigger": "timeout",
      "window_duration": 38.88379043312195
    },
    {
      "file_path": "bst.cpp",
      "diffs": "+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n\n// ... more methods ...\n\n// ... more methods ...\n",
      "active_symbol": "remove",
      "trigger": "timeout",
      "window_duration": 32.55068555315052
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+if (node == nullptr) {\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n\n// ... more methods ...\n\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\n",
      "active_symbol": "remove",
      "trigger": "timeout",
      "window_duration": 35.89735208603372
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+if (node == nullptr) {\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n\n// ... more methods ...\n\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\n",
      "active_symbol": "remove",
      "trigger": "timeout",
      "window_duration": 39.38872349072174
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+if (node == nullptr) {\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n\n// ... more methods ...\n\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\n",
      "active_symbol": "remove",
      "trigger": "timeout",
      "window_duration": 34.37792162082061
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+if (node == nullptr) {\n+        return nullptr;\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n\n// ... more methods ...\n\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\n",
      "active_symbol": "remove",
      "trigger": "timeout",
      "window_duration": 39.25550050281632
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+if (node == nullptr) {\n+        return nullptr;\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n\n// ... more methods ...\n\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\n",
      "active_symbol": "remove",
      "trigger": "timeout",
      "window_duration": 39.04716257329697
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+if (node == nullptr) {\n+        return nullptr;\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n\n// ... more methods ...\n\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\n",
      "active_symbol": "remove",
      "trigger": "timeout",
      "window_duration": 36.09652419195898
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+if (node == nullptr) {\n+        return nullptr;\n+    }\n+    \n+    if (value < node->value) {\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n\n// ... more methods ...\n\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\n",
      "active_symbol": "remove",
      "trigger": "timeout",
      "window_duration": 34.21993636901479
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+if (node == nullptr) {\n+        return nullptr;\n+    }\n+    \n+    if (value < node->value) {\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n\n// ... more methods ...\n\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\n",
      "active_symbol": "remove",
      "trigger": "timeout",
      "window_duration": 35.54861184322545
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+if (node == nullptr) {\n+        return nullptr;\n+    }\n+    \n+    if (value < node->value) {\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n\n// ... more methods ...\n\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\n",
      "active_symbol": "remove",
      "trigger": "timeout",
      "window_duration": 37.07482841924362
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+if (node == nullptr) {\n+        return nullptr;\n+    }\n+    \n+    if (value < node->value) {\n+        node->left = removeHelper(node->left, value);\n+    } else if (value > node->value) {\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n\n// ... more methods ...\n\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\n",
      "active_symbol": "remove",
      "trigger": "timeout",
      "window_duration": 35.765738745889195
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+if (node == nullptr) {\n+        return nullptr;\n+    }\n+    \n+    if (value < node->value) {\n+        node->left = removeHelper(node->left, value);\n+    } else if (value > node->value) {\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n\n// ... more methods ...\n\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\n",
      "active_symbol": "remove",
      "trigger": "timeout",
      "window_duration": 34.638026631328415
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+if (node == nullptr) {\n+        return nullptr;\n+    }\n+    \n+    if (value < node->value) {\n+        node->left = removeHelper(node->left, value);\n+    } else if (value > node->value) {\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n\n// ... more methods ...\n\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\n",
      "active_symbol": "remove",
      "trigger": "timeout",
      "window_duration": 38.98359014845339
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+// ... recursive cases ...\n+    } else {\n+        // Node found - handle cases\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n\n// ... more methods ...\n\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n",
      "active_symbol": "remove",
      "trigger": "timeout",
      "window_duration": 36.326471174541204
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+// ... recursive cases ...\n+    } else {\n+        // Node found - handle cases\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n\n// ... more methods ...\n\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n",
      "active_symbol": "remove",
      "trigger": "timeout",
      "window_duration": 35.709857917299196
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+// ... recursive cases ...\n+    } else {\n+        // Node found - handle cases\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n\n// ... more methods ...\n\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n",
      "active_symbol": "remove",
      "trigger": "timeout",
      "window_duration": 39.24029573956004
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+// Single child case\n+        if (node->left == nullptr) {\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n\n// ... more methods ...\n\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// Single child case\n        if (node->left == nullptr) {\n// ... more methods ...\n",
      "active_symbol": "remove",
      "trigger": "timeout",
      "window_duration": 39.75004317320541
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+// Single child case\n+        if (node->left == nullptr) {\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n\n// ... more methods ...\n\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// Single child case\n        if (node->left == nullptr) {\n// ... more methods ...\n// Single child case\n        if (node->left == nullptr) {\n// ... more methods ...\n",
      "active_symbol": "remove",
      "trigger": "timeout",
      "window_duration": 36.71963300062566
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+// Single child case\n+        if (node->left == nullptr) {\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n\n// ... more methods ...\n\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// Single child case\n        if (node->left == nullptr) {\n// ... more methods ...\n// Single child case\n        if (node->left == nullptr) {\n// ... more methods ...\n// Single child case\n        if (node->left == nullptr) {\n// ... more methods ...\n",
      "active_symbol": "remove",
      "trigger": "timeout",
      "window_duration": 37.53254819534316
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+// Two children - find min in right subtree\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n\n// ... more methods ...\n\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// Single child case\n        if (node->left == nullptr) {\n// ... more methods ...\n// Single child case\n        if (node->left == nullptr) {\n// ... more methods ...\n// Single child case\n        if (node->left == nullptr) {\n// ... more methods ...\n// Two children - find min in right subtree\n// ... more methods ...\n",
      "active_symbol": "remove",
      "trigger": "timeout",
      "window_duration": 37.35874512744927
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+// Two children - find min in right subtree\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n\n// ... more methods ...\n\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// Single child case\n        if (node->left == nullptr) {\n// ... more methods ...\n// Single child case\n        if (node->left == nullptr) {\n// ... more methods ...\n// Single child case\n        if (node->left == nullptr) {\n// ... more methods ...\n// Two children - find min in right subtree\n// ... more methods ...\n// Two children - find min in right subtree\n// ... more methods ...\n",
      "active_symbol": "remove",
      "trigger": "timeout",
      "window_duration": 36.12483828579218
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+Node* minRight = findMin(node->right);\n+        node->value = minRight->value;\n+        node->right = removeHelper(node->right, minRight->value);\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n\n// ... more methods ...\n\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// Single child case\n        if (node->left == nullptr) {\n// ... more methods ...\n// Single child case\n        if (node->left == nullptr) {\n// ... more methods ...\n// Single child case\n        if (node->left == nullptr) {\n// ... more methods ...\n// Two children - find min in right subtree\n// ... more methods ...\n// Two children - find min in right subtree\n// ... more methods ...\nNode* minRight = findMin(node->right);\n        node->value = minRight->value;\n        node->right = removeHelper(node->right, minRight->value);\n// ... more methods ...\n",
      "active_symbol": "remove",
      "trigger": "timeout",
      "window_duration": 37.40504456927187
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+if (node == nullptr) {\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n\n// ... more methods ...\n\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// Single child case\n        if (node->left == nullptr) {\n// ... more methods ...\n// Single child case\n        if (node->left == nullptr) {\n// ... more methods ...\n// Single child case\n        if (node->left == nullptr) {\n// ... more methods ...\n// Two children - find min in right subtree\n// ... more methods ...\n// Two children - find min in right subtree\n// ... more methods ...\nNode* minRight = findMin(node->right);\n        node->value = minRight->value;\n        node->right = removeHelper(node->right, minRight->value);\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\n",
      "active_symbol": "helper",
      "trigger": "timeout",
      "window_duration": 67.18484958652188
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+if (node == nullptr) {\n+        return new Node(value);\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n\n// ... more methods ...\n\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// Single child case\n        if (node->left == nullptr) {\n// ... more methods ...\n// Single child case\n        if (node->left == nullptr) {\n// ... more methods ...\n// Single child case\n        if (node->left == nullptr) {\n// ... more methods ...\n// Two children - find min in right subtree\n// ... more methods ...\n// Two children - find min in right subtree\n// ... more methods ...\nNode* minRight = findMin(node->right);\n        node->value = minRight->value;\n        node->right = removeHelper(node->right, minRight->value);\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\n",
      "active_symbol": "helper",
      "trigger": "timeout",
      "window_duration": 69.17602874580297
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+if (node == nullptr) {\n+        return new Node(value);\n+    }\n+    \n+    if (value < node->value) {\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n\n// ... more methods ...\n\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// Single child case\n        if (node->left == nullptr) {\n// ... more methods ...\n// Single child case\n        if (node->left == nullptr) {\n// ... more methods ...\n// Single child case\n        if (node->left == nullptr) {\n// ... more methods ...\n// Two children - find min in right subtree\n// ... more methods ...\n// Two children - find min in right subtree\n// ... more methods ...\nNode* minRight = findMin(node->right);\n        node->value = minRight->value;\n        node->right = removeHelper(node->right, minRight->value);\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\n",
      "active_symbol": "helper",
      "trigger": "timeout",
      "window_duration": 67.02944660219536
    },
    {
      "file_path": "bst.cpp",
      "diffs": "-\n+if (node == nullptr) {\n+        return new Node(value);\n+    }\n+    \n+    if (value < node->value) {\n+        node->left = insertHelper(node->left, value);\n+    } else if (value > node->value) {\n+        node->right = insertHelper(node->right, value);\n+    }\n+    \n+    return node;\n+// ... more methods ...\n+",
      "content": "#include \"bst.h\"\n\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorder() {\n    inorderHelper(root);\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\nvoid BST::inorderHelper(Node* node) {\n    if (node == nullptr) return;\n// ... more methods ...\ninorderHelper(node->left);\n    std::cout << node->value << \" \";\n    inorderHelper(node->right);\n// ... more methods ...\n\n// ... more methods ...\n\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return nullptr;\n    }\n    \n    if (value < node->value) {\n        node->left = removeHelper(node->left, value);\n    } else if (value > node->value) {\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// ... recursive cases ...\n    } else {\n        // Node found - handle cases\n// ... more methods ...\n// Single child case\n        if (node->left == nullptr) {\n// ... more methods ...\n// Single child case\n        if (node->left == nullptr) {\n// ... more methods ...\n// Single child case\n        if (node->left == nullptr) {\n// ... more methods ...\n// Two children - find min in right subtree\n// ... more methods ...\n// Two children - find min in right subtree\n// ... more methods ...\nNode* minRight = findMin(node->right);\n        node->value = minRight->value;\n        node->right = removeHelper(node->right, minRight->value);\n// ... more methods ...\nif (node == nullptr) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n// ... more methods ...\nif (node == nullptr) {\n        return new Node(value);\n    }\n    \n    if (value < node->value) {\n        node->left = insertHelper(node->left, value);\n    } else if (value > node->value) {\n        node->right = insertHelper(node->right, value);\n    }\n    \n    return node;\n// ... more methods ...\n",
      "active_symbol": "helper",
      "trigger": "timeout",
      "window_duration": 67.59531023086603
    },
    {
      "file_path": "main.cpp",
      "diffs": "-\n+#include <iostream>\n+#include \"bst.h\"\n+\n+int main()  {\n+    BST tree;\n+\n+    // Insert values\n+    int values[] = {50, 30, 70, 20, 40, 60, 80};\n+    for (int val : values)  {\n+        tree.insert(val);\n+    }\n+\n+    std::cout << \"Inorder: \";\n+    tree.inorder();\n+\n+    std::cout << \"Height: \" << tree.height() << std::endl;\n+    std::cout << \"Count: \" << tree.nodeCount() << std::endl;\n+\n+    // Search\n+    std::cout << \"Search 40: \" << (tree.search(40) ? \"Found\" : \"Not found\") << std::endl;\n+\n+    // Remove\n+    tree.remove(30);\n+    std::cout << \"After removing 30: \";\n+    tree.inorder();\n+\n+    return 0;\n+}\n+",
      "content": "#include <iostream>\n#include \"bst.h\"\n\nint main()  {\n    BST tree;\n\n    // Insert values\n    int values[] = {50, 30, 70, 20, 40, 60, 80};\n    for (int val : values)  {\n        tree.insert(val);\n    }\n\n    std::cout << \"Inorder: \";\n    tree.inorder();\n\n    std::cout << \"Height: \" << tree.height() << std::endl;\n    std::cout << \"Count: \" << tree.nodeCount() << std::endl;\n\n    // Search\n    std::cout << \"Search 40: \" << (tree.search(40) ? \"Found\" : \"Not found\") << std::endl;\n\n    // Remove\n    tree.remove(30);\n    std::cout << \"After removing 30: \";\n    tree.inorder();\n\n    return 0;\n}\n",
      "active_symbol": "main",
      "trigger": "timeout",
      "window_duration": 5.760921805825163
    }
  ]
}